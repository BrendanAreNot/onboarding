2.1 - Workflow Exercises

2.1.2 - Artifacts Exercises

1. Compare and contrast how we use snapshot and release versions of artifacts in the daily
workflow.




2. Identify the classifiers and file types for the artifacts found in the following snapshot directory:
s3://com.esc.data/snapshot/com/esc/data/tulsa-2014/2.3.0-SNAPSHOT/




3. Find the corresponding release directory for the snapshot in the previous question.




4. Copy the .pom file for the 2.3.0 release version of the Tulsa 2014 project to your local direc-
tory. Name the group ID, artifact ID, and version number for the dependencies listed. Find
the line numbers on which the classifiers and types for the artifacts are declared. Then,
write a summary of your findings (i.e., what does it mean for these artifacts to be listed as
dependencies?).




5. Copy the latest ESCalate documentation file. This will be a great reference to have as you
complete more onboarding tasks. Find the latest version in:
s3://com.esc.artifacts/release/com/esc/doc/escalate/
Copy the pdf to your local repo. There are .zip files you can download as well, but the pdf is
easier to search.



2.1.3 - Semantic Versioning Exercises

1. Identify the parts of a semantic version. What does each part mean?

Semantic versioning uses the following format: MAJOR.MINOR.PATCH-(pre-release)+(metadata) [1.0.0-alpha+001 as an example]

MAJOR (X.0.0) changes are made whenever an update would be incompatible with older versions or changes. For example, if a program that only performed the "add" function had changes made to how it outputs or inputs information, that would constitute a Major version update since other programs that rely on those inputs/outputs would be incompatible.

MINOR (0.X.0) changes are made whenever new features are added in a backward-compatible manner. Using the "add" program from the previous example, implementing a "subtract" feature would be a Minor update since it does not interfere with the functionality of the "add" feature. Changes that may seem major but implement some default value with a change can be considered Minor as well since they wouldn't break anything.

PATCH (0.0.X) changes are made whenever backward-compatible bug fixes are made. Making changes to the "add" program to fix a bug would be a Patch. As long as it doesn't add functionality or break previous versions, it is a Patch.

Pre-release and metadata components can be added to provide additional information (metadata) or let users know that certain functions may be incomplete (pre-release) but neither are mandatory.

Whenever a MAJOR or MINOR update is made, lesser changes are reset to 0. For example: Version 3.4.8 receives a MAJOR update and becomes Version 4.0.0. Version 3.4.8 receives a MINOR update and becomes Version 3.5.0.
Keep in mind that precedence is established from left to right (Major to Pre-release). When two versions are identical except for metadata, they have equal precedence.
Therefore, 1.0.0-alpha+002 = 1.0.0-alpha+003 < 1.0.0-beta < 1.0.0 < 1.0.1 < 1.1.0 < 2.0.0


2. Consider the development of the following JavaScript function amazing:

function amazing(){
return "Awsome";
}

Call this version 1.0.0.

a. Suppose we recognize that we made a mistake in the original function and correct it
as follows:

function amazing(){
return "Awesome";
}

What should this new version be called?

Since a bug has been fixed and no features have been changed, a Patch has been implemented and the new version is 1.0.1


b. Suppose we next make the following change:

function amazing(language){
if(language == null)
throw new Error("Language argument must be provided.");
return language === "fr" ? "Génial":"Awesome";
}

What should this version now be called?

Since this update includes changes to how the function is used by requiring a "language" argument without including a default, it breaks old versions. This means it is a Major change and the new version is 2.0.0


c. Suppose we next make the following change:
function amazing(language){
if(language == null)
throw new Error("Language argument must be provided.");
return language === "fr" ? "Génial" : language === "de" : "Spitze" : "Awsome";
}

What should this version now be called?

Since this update adds a new language but does not change the pre-existing one, it is a Minor change. The new version is 2.1.0


d. Suppose we next make the following change:

function amazing(language){
if(language == null)
throw new Error("Language argument must be provided.");
return language === "fr" ? "Génial" : language === "de" : "Spitze" : "Awesome";
}

What should this version now be called?

This change fixes a typo and changes "Awsome" to "Awesome". This is a bug fix or Patch and the new version is 2.1.1
