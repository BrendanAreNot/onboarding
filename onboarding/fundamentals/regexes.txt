1.5.2 Exercises

1. What is a regular expression?

A regular expression, or regex, is a series of symbols and shorthands used to describe a pattern in text. Text can then be searched using these patterns and matching (or non-matching) text can be returned.


2. What are common use cases for regular expressions?

Regular expressions are commonly used to search through text quickly and efficiently. For example, a regex could be used to find all cases of a phone number or an email. A single regex search can outperform a plan text search by five times.


3. When should you (not) use regular expressions?

Regular expressions are a powerful tool that can be used often. Being able to pull information and patterns from text is very useful. However, regular expressions aren't efficient with all types of text. Writing regex for HTML or XML is very difficult and inefficient. Other tools are available for those formats specifically. Additionally, certain tasks can be done more effectively with simple tools rather than a complex regex. Don't make things more difficult! Regular expres


4. What is a greedy quantifer?

A greedy quantifier, like the +, is a quantifier that encourages the regex engine to repeat something as often as possible. This means that the feature or request will repeat for as long as it can before the engine looks at the next token. In the example provided by Regular-Expressions.info, the regex <.+> will check for the starting character < then check for any character after until it reaches the end of the string. Once there, the regex will try to match the ending > token. When the token cannot be matched, the regex engine will backtrack, slowly taking off iterations until the > token can be matched. Once the token is matched, the regex engine stops. What this means is that a greedy quantifier can involve a lot of backtracking. In addition, it can also give unexpected answers. The example string "This is a <EM>first</EM> test" paired with the regex <.+> was supposed to match <EM> and </EM>. However, the greedy quantifier encountered the second > as it was backtracking. Therefore the output was <EM>first</EM>, which was unintended.
Curly braces and the star are also considered greedy.


5. What is a non-greedy (lazy) quantifier?

A lazy quantifier uses the ? to make a greedy quantifier an "ungreedy" or "reluctant" quantifier. Instead of running amok, reaching the end, and working backwards to fix the mistake, the lazy quantifier goes slower. The regex <.+?> will check for a < and then check for any single character after that. Unlike the greedy quantifier, the lazy quantifier will then check the next token, >, and see if it matches the next character. If it doesn't, the lazy quantifier backtracks in order to expand the reach of the .+ component. It will try again and search for any two characters. This process of checking, backtracking, adding, and checking again repeats until the > is found. In this case, the lazy quantifier has given the expected result of <EM> and </EM>


6. What is the behavior of a non-greedy quantifier?




7. What is a character class?




8. What shorthand character classes are typically available?




9. What is a group?




10. What is a postitive lookahead?




11. What is a negative lookahead?




12. What is a postive lookbehind?




13. What is a negative lookbehind?




14. What is a back reference?




15. What are common flags? How do you specify them?




16. What is the common regular expression syntax?




17. How do you identify the start and end of a line?




18. How do you specify a regex as case-insensitive?




19. How do you indicate that a character must occur:
a. 0 or more times?
b. 1 or more times?
c. 0 or 1 times?
d. n (> 0) times?
e. n (> 0) or more times?
f. at least n (> 0) but no more than m (> n) times?
g. no more than m (> 0) times?




20. How do you refer to the collection of:
a. Alpha characters?
b. Non-alpha characters?
c. Digits?
d. Non-digits?
e. Alphanumeric characters?
f. Non-alphanumeric characters?
g. White space characters?
h. Non-white space characters?
Are there multiple approaches to the above questions? If so, what are they?




21. How do you indicate that any character is acceptable?




22. How do you indicate that a ’?’ is acceptable?




23. How do you indicate that a ’[’ is acceptable?




24. How do you indicate that ’\’ and ’w’ are acceptable?




25. How do you account for a newline character between words?




26. How do you indicate that any alpha character not ’a’, ’b’, or ’c’ is permitted?




27. How do you indicate that any word character not ’a’, ’b’, or ’c’ is permitted?




28. How do you indicate that any 10 digit ID without a digit occurring 3 times in a row is permitted?




29. How do you extend the preceding regex to disallow leading 0s?




30. How do you indicate that ’foo’ or ’bar’ is acceptable?




31. How do you indicate that ’foo’ must be immediately followed by ’bar’?




32. How do you indicate that ’foo’ must not be immediately followed by ’bar’?




33. How do you indicate that ’bar’ must be immediately preceded by ’foo’?




34. How do you indicate that ’bar’ must not be immediately preceded by ’foo’?




35. How do you identify individual words?




36. Craft a regex to match any time in the 24 hour HH:MM format.




37. Extend the preceding regex to extract the hour and minute components.




38. Craft a regex to match dates in the DD/MM/YYYY format; day and month may have 1 or 2
characters (e.g., ’1’ and ’01’ are valid days).




39. Consider the XML snippet "<node>abd 123</node>". Craft a regular expression that will
return 2 matches: "<node>", "</node>".




40. Suppose that you’ve defined variables below that are referenced throughout your scripts.
You need to refactor them s.t. the prefix and suffice are swapped; e.g., prop1_obj becomes
obj_prop1. How would you use a regular expression to do this in Gedit (the default text editor
in our VMs)?

	prop1_obj
	prop2_obj
	prop3_obj